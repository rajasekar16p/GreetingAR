<!DOCTYPE html>
<html lang="en">
<head>
	<title>Happy New Year 2023 - Aatral</title>
	<!--<title>Adiós 2022! Hola 2023!</title>-->

	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
	<link rel="shortcut icon" type="image/jpg" href="textures/aatral_logo_square.jpg" />
</head>
<body>

	<div id="info">
		<a href="#" target="_blank" rel="noopener">Adiós 2022! Hola 2023</a>
	</div>

	<!--<div id="logo" onclick="location.href='https://aatral.io/';"  >-->
	<div id="logo" " >
		<!--<a href="https://aatral.io/" target="_blank" rel="noopener">three.js</a>-->
		<a href="https://aatral.io/" target="_blank" rel="noopener noreferrer">
			<span class="span_link"></span>
		</a>

	</div>

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
			"imports": {
				"three": "./build/three.module.js",
				"three/addons/": "./jsm/",
				"three/nodes": "./jsm/nodes/Nodes.js"
			}
		}
	</script>

	<script type="module">

		import * as THREE from 'three';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { ARButton } from 'three/addons/webxr/ARButton.js';

		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

		import Stats from 'three/addons/libs/stats.module.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

		//TextS
		import { FontLoader } from 'three/addons/loaders/FontLoader.js';
		import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
		import { AmbientLight } from 'three';

		let textMesh1, textMesh2, textGeo, textMaterials;
		let text = 'HAPPY NEW \n YEAR  2023',
			bevelEnabled = true,
			font = undefined,
			fontName = 'optimer', // helvetiker, optimer, gentilis, droid sans, droid serif
			fontWeight = 'bold'; // normal bold

		const height = 0.0001,
			size = 0.25,
			hover = 0,
			curveSegments = 4,
			bevelThickness = 0.04,
			bevelSize = 0.015;

		const mirror = false;

		let fbxLoader;

		let stats, parameters;
		const materials = [];
		let mouse = { X: 0, Y: 0 };

		let windowHalfX = window.innerWidth / 2;
		let windowHalfY = window.innerHeight / 2;

		//Text

		let container;
		let camera, scene, renderer;
		let controller1, controller2;

		let raycaster;

		const intersected = [];
		const tempMatrix = new THREE.Matrix4();

		let group;
		let balloon, star, snow, bell1, bell2;
		let colorThemeSelection = 0;
		let snowflake = false;
		let isSnowParticleEffect = false;

		const API = {
			background_color: 0x000000,
			changeColor: function () {
				ChangeBackgroundColor();
			},
			background_AR: function () {
				RemoveBackground();
			},
			changeTheme: function () {
				ChangeTheme();
			},
			addSnowflakes: function () {
				snowflake = true;
			}
		};

		const ColorPalatte = {
			patetteId: 0,
			background_color: 0x000000,
			primary_color: 0x000000,
			secondary_color: 0x000000,
			text3dForegroundColor: 0x000000,
			text3dSideColor: 0x000000,
			other_color: [0x000000, 0x000000, 0x000000, 0x000000],
		};

		let isAudioPlaying = false;

		const addAudioListenerToCamera = (camera) => {
			if (!isAudioPlaying) {
				isAudioPlaying = true;
                AudioPlayer();
            }
		};

		let particleSpriteLocation = "./textures/sprites/snowflake/";

		init();
		animate();
		animateParticles();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			ColorThemeSetter(colorThemeSelection);//Set color there to 0

			scene = new THREE.Scene();
			//  scene.background = new THREE.Color(0x56A2FF); //Enable for background

			//camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
			camera.position.set(0, 0, 3);

            document.addEventListener("click", () => {
                addAudioListenerToCamera(camera);
			});

			const controls = new OrbitControls(camera, container);
			controls.minDistance = 0;
			controls.maxDistance = 8;

			scene.add(new THREE.HemisphereLight(0x808080, 0x606060));

			const light = new THREE.DirectionalLight(0xffffff);
			light.position.set(0, 6, 0);
			scene.add(light);
			const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
			scene.add(ambientLight);

			group = new THREE.Group();
			scene.add(group);

			if (snowflake) {
				initateSnowParticles(); //Enable for snow particles
			}

			//
			//Texts
			loadFont();

			//text
			//ModelS
			//const loader = new GLTFLoader().setPath('models/newyear/gltf/snow_fx/');
			//loader.load('scene.gltf', function (gltf) {
			//	const model = gltf.scene;

			//	gltf.scene.scale.set(5, 5, 5) // scale here
			//	scene.add(gltf.scene);
			//});

			// model
			fbxLoader = new FBXLoader();
			fbxLoader.load('models/newyear/fbx/balloon/Balloon.fbx', function (object) {
				balloon = object;
				//object.scale.setScalar(getRandomFloat(0.35, 0.6));
				//object.position.z = -1;
				//scene.add(object);
			});

			fbxLoader = new FBXLoader();
			fbxLoader.load('models/newyear/fbx/gold-star/source/gold star.fbx', function (object) {
				star = object;
				object.scale.setScalar(0.0001);
				object.position.x = 0;
				object.position.y = 0.5;
				object.position.z = -1;

				scene.add(object);
			});

			fbxLoader = new FBXLoader();
			fbxLoader.load('models/newyear/fbx/christmas-bell/source/bell.fbx', function (object) {
				bell1 = object;
				//object.scale.setScalar(0.001);
			});

			fbxLoader = new FBXLoader();
			fbxLoader.load('models/newyear/fbx/jingle-bell/source/bell.fbx', function (object) {
				bell2 = object;
				//            object.scale.setScalar(0.025);
			});

			//model
			const geometries = [
				//new THREE.ConeGeometry(0.2, 0.2, 64),
				new THREE.IcosahedronGeometry(0.2, 8)
			];

			for (let i = 0; i < 50; i++) {
				if (i % 2 == 0) {

					const geometry = geometries[Math.floor(Math.random() * geometries.length)];
					const material = new THREE.MeshStandardMaterial({
						//color: Math.random() * 0xffffff,
						color: getRandomBalloonColor(),
						opacity: 0.75,
						transparent: true,
						roughness: 0.7,
						metalness: 0.0
					});

					const object = new THREE.Mesh(geometry, material);

					object.position.x = Math.random() * 8 - 4;
					object.position.y = Math.random() * 8 - 4;
					object.position.z = Math.random() * 8 - 4;

					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;

					object.scale.setScalar(Math.random() + 0.5);
					object.name = i;
					group.add(object);
				}
				else {
					let randomValue = Math.floor(getRandomFloat(0, 1));
					createClones(randomValue, i);
				}
			}
			//

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.xr.enabled = true;
			container.appendChild(renderer.domElement);

			document.body.appendChild(ARButton.createButton(renderer));

			// controllers
			controller1 = renderer.xr.getController(0);
			controller1.addEventListener('selectstart', onSelectStart);
			controller1.addEventListener('selectend', onSelectEnd);
			scene.add(controller1);

			controller2 = renderer.xr.getController(1);
			controller2.addEventListener('selectstart', onSelectStart);
			controller2.addEventListener('selectend', onSelectEnd);
			scene.add(controller2);

			raycaster = new THREE.Raycaster();

			const gui = new GUI();

			gui.addColor(API, 'background_color')
				.listen()
				.onChange(function () {
					scene.background = new THREE.Color(API.background_color);//.convertSRGBToLinear();
					//mesh.material.color.set(API.background-color).convertSRGBToLinear();
					render();

				});
			//gui.add({ enabled: false }, 'enabled')
			//             .name('Show Background')
			//             .onChange(value => {
			//		scene.background = null;
			//                 render();

			//             });
			gui.add(API, 'background_AR').name('AR Background');
			gui.add(API, 'changeColor').name('Change background color');
			gui.add(API, 'changeTheme').name('Change Theme -Temp');
			gui.add(API, 'addSnowflakes').name('Snow');

			// Showing stats
			stats = new Stats();
			document.body.appendChild(stats.dom);

			window.addEventListener('resize', onWindowResize);
		}

		//Setups the particle system
		function initateSnowParticles() {
			scene.fog = new THREE.FogExp2(0x000000, 0.0008);

			const particleSystems = createParticleSystems();

			// Add particleSystems to scene
			for (let i = 0; i < particleSystems.length; i++) {
				scene.add(particleSystems[i]);
			}
		}

		//Create clone of the loaded models(ballons)
		function createClones(value, i) {
			switch (value) {
				case 0:
					const materialFbx = new THREE.MeshStandardMaterial({
						//color: Math.random() * 0x6Effff,
						color: getRandomBalloonColor(),
						opacity: 0.9,
						transparent: true,
						roughness: 0.5,
						metalness: 0.1
					});

					fbxLoader.load('models/newyear/fbx/balloon/Balloon.fbx', function (object) {
						const newObject = balloon.clone();
						newObject.position.x = Math.random() * 4 - 2;
						newObject.position.y = Math.random() * 4 - 2;
						newObject.position.z = Math.random() * 8 - 4;
						//newObject.position.z = Math.random() * (i < 25 ? i + 1 : -(i - 25));
						console.log(newObject.position.z);
						newObject.rotation.x = Math.random() * 2 * Math.PI;
						newObject.rotation.y = Math.random() * 2 * Math.PI;

						newObject.scale.setScalar(getRandomFloat(0.2, 0.7));
						newObject.children[1].material = materialFbx;
						newObject.name = i + "_ball_obj";
						group.add(newObject);
					});
					break;
				case 1:
					fbxLoader.load('models/newyear/fbx/gold-star/source/gold star.fbx', function (object) {
						const newObject = star.clone();
						newObject.position.x = Math.random() * 4 - 2;
						newObject.position.y = Math.random() * 4 - 2;
						newObject.position.z = Math.random() * 4 - 2;

						newObject.rotation.y = Math.random() * 2 * Math.PI;

						newObject.scale.setScalar(getRandomFloat(0.00008, 0.0001));
						newObject.name = i + "_star_obj";
						group.add(newObject);
					});
					break;
				case 2:
					fbxLoader.load('models/newyear/fbx/christmas-bell/source/bell.fbx', function (object) {
						const newObject = bell1.clone();
						newObject.position.x = Math.random() * 4 - 2;
						newObject.position.y = Math.random() * 4 - 2;
						newObject.position.z = Math.random() * 4 - 2;

						newObject.rotation.y = Math.random() * 2 * Math.PI;

						newObject.scale.setScalar(getRandomFloat(0.00075, 0.001));

						newObject.name = i + "_bell1_obj";
						group.add(newObject);
					});
				case 3:
					fbxLoader.load('models/newyear/fbx/jingle-bell/source/bell.fbx', function (object) {
						const newObject = bell2.clone();
						newObject.position.x = Math.random() * 4 - 2;
						newObject.position.y = Math.random() * 4 - 2;
						newObject.position.z = Math.random() * 4 - 2;

						newObject.rotation.y = Math.random() * 2 * Math.PI;

						newObject.scale.setScalar(getRandomFloat(0.010, 0.015));

						newObject.name = i + "_bell2_obj";
						group.add(newObject);
					});
			}
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function onSelectStart(event) {
			const controller = event.target;

			const intersections = getIntersections(controller);

			if (intersections.length > 0) {

				const intersection = intersections[0];

				const object = intersection.object;
				object.material.emissive.b = 1;
				controller.attach(object);

				controller.userData.selected = object;
			}
		}

		function onSelectEnd(event) {
			const controller = event.target;

			if (controller.userData.selected !== undefined) {

				const object = controller.userData.selected;
				object.material.emissive.b = 0;
				group.attach(object);

				controller.userData.selected = undefined;
			}
		}

		function getIntersections(controller) {
			tempMatrix.identity().extractRotation(controller.matrixWorld);

			raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
			raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

			return raycaster.intersectObjects(group.children, false);
		}

		function intersectObjects(controller) {
			// Do not highlight when already selected
			if (controller.userData.selected !== undefined) return;

			const intersections = getIntersections(controller);

			if (intersections.length > 0) {

				const intersection = intersections[0];

				const object = intersection.object;
				if (object.material.emissive != null) {
					object.material.emissive.r = 1;
					intersected.push(object);
				}

			}
		}

		function cleanIntersected() {
			while (intersected.length) {

				const object = intersected.pop();
				object.material.emissive.r = 0;
			}
		}

		function animate() {
			renderer.setAnimationLoop(render);
		}

		function animateParticles() {
			// This will create a loop rendering at each frame
			requestAnimationFrame(animateParticles);
			render();
			stats.update();
		}

		function render() {
			//ParticlesStart
			//const time = Date.now() * 0.00005;
            let time = Date.now() * 0.00002;

			if (isSnowParticleEffect) {
                time = Date.now() * 0.00002;
				for (let i = 0; i < scene.children.length; i++) {
					const object = scene.children[i];

					if (object instanceof THREE.Points) {
						object.rotation.y = time * (i < 4 ? i + 1 : -(i + 1));
					}
				}

				for (let i = 0; i < materials.length; i++) {
					const color = parameters[i][0];
					const h = (360 * ((color[0] + time) % 360)) / 360;
					materials[i].color.setHSL(h, color[1], color[2]);
				}
			}
			else {
                 time = Date.now() * 0.00001;

                for (let i = 0; i < scene.children.length; i++) {
                    const object = scene.children[i];

					if (object instanceof THREE.Points) {
						object.rotation.x = time * (i < 4 ? i + 1 : -(i + 1));
                        object.rotation.y = time * (i < 4 ? i + 1 : -(i + 1));
                        object.rotation.z = time * (i < 4 ? i + 1 : -(i + 1));
                    }
                }
            }
			//Particles end

			//To rotate the 3d models in the group(balloons, stars, sphere etc)
            for (let i = 0; i < group.children.length; i++) {
                const object = group.children[i];
                object.rotation.y = time * (i < 4 ? i + 1 : -(i + 1));
            }

			cleanIntersected();

			intersectObjects(controller1);
			intersectObjects(controller2);

			renderer.render(scene, camera);
		}

		//TextS
		//To load the font
		function loadFont() {

			const loader = new FontLoader();
			loader.load('fonts/' + fontName + '_' + fontWeight + '.typeface.json', function (response) {

				font = response;

				refreshText();
			});
		}

		//Creates the new year text model
		function createText() {
			//textMaterials = [
			//	new THREE.MeshPhongMaterial({ color: 0xff0000, flatShading: true }), // front
			//	new THREE.MeshPhongMaterial({ color: 0xffffff }) // side
			//];
			textMaterials = [
				new THREE.MeshPhongMaterial({ color: ColorPalatte.text3dForegroundColor, flatShading: true }), // front
				new THREE.MeshPhongMaterial({ color: ColorPalatte.text3dSideColor }) // side
			];

			textGeo = new TextGeometry(text, {
				font: font,
				size: size,
				height: height,
				curveSegments: curveSegments,
				bevelThickness: bevelThickness,
				bevelSize: bevelSize,
				bevelEnabled: bevelEnabled
			});
			textGeo.computeBoundingBox();

			const centerOffset = - 0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);

			textMesh1 = new THREE.Mesh(textGeo, textMaterials);

			textMesh1.position.x = centerOffset;
			textMesh1.position.y = hover;
			textMesh1.position.z = -1;

			textMesh1.rotation.x = 0;
			textMesh1.rotation.y = Math.PI * 2;

			textMesh1.name = "textmesh1";
			//group.add(textMesh1);
			scene.add(textMesh1);

			if (mirror) {
				textMesh2 = new THREE.Mesh(textGeo, textMaterials);

				textMesh2.position.x = centerOffset;
				textMesh2.position.y = - hover;
				textMesh2.position.z = height;

				textMesh2.rotation.x = Math.PI;
				textMesh2.rotation.y = Math.PI * 2;
				textMesh2.name = "textmesh2";

				//group.add(textMesh2);
			}
		}

		//refresh the text model
		function refreshText() {
			group.remove(textMesh1);
			if (mirror) group.remove(textMesh2);

			if (!text) return;

			createText();
		}

		//Text
		//Get random float number between two values
		function getRandomFloat(min, max) {
			return Math.random() * (max - min) + min;
		}

		//Returns random color for material from theme color palette
		function getRandomBalloonColor() {
			const randomVal = Math.floor(getRandomFloat(0, 4));
			const color = ColorPalatte.other_color[randomVal];
			//const color = Math.random() * 0x4CAAFF;
			return color;
		}

		//Particle system for snow and confetti
		function createParticleSystems() {
			// Load the texture that will be used to display our snow
			const textureLoader = new THREE.TextureLoader();

			const sprite1 = textureLoader.load(
				particleSpriteLocation + "particle1.png"
			);
			const sprite2 = textureLoader.load(
                particleSpriteLocation + "particle2.png"
			);
			const sprite3 = textureLoader.load(
                particleSpriteLocation + "particle3.png"
			);
			const sprite4 = textureLoader.load(
                particleSpriteLocation + "particle4.png"
			);
			const sprite5 = textureLoader.load(
                particleSpriteLocation + "particle5.png"
			);

			// Create the geometry that will hold all our vertices
			const geometry = new THREE.BufferGeometry();
			const vertices = [];
			const particleSystems = [];

			// create the vertices and add store them in our vertices array
			for (let i = 0; i < 10000; i++) {
				const x = Math.random() * 2000 - 1000; // generate random number between -1000 to 1000
				const y = Math.random() * 2000 - 1000;
				const z = Math.random() * 2000 - 1000;

				vertices.push(x, y, z);
			}

			// Add the vertices stored in our array to set
			// the position attribute of our geometry.
			// Position attribute will be read by threejs
			geometry.setAttribute(
				"position",
				new THREE.Float32BufferAttribute(vertices, 3)
			);

			parameters = [
				[[1.0, 0.2, 0.5], sprite2, 20],
				[[0.95, 0.2, 0.5], sprite3, 15],
				[[0.9, 0.2, 0.5], sprite1, 10],
				[[0.85, 0.2, 0.5], sprite5, 8],
				[[0.8, 0.2, 0.5], sprite4, 5],
			];

			for (let i = 0; i < parameters.length; i++) {
				const color = parameters[i][0];
				const sprite = parameters[i][1];
				const size = parameters[i][2];

				// Create the material that will be used to render each vertex of our geometry
				materials[i] = new THREE.PointsMaterial({
					size,
					map: sprite,
					blending: THREE.AdditiveBlending,
					depthTest: false,
					transparent: true,
				});
				materials[i].color.setHSL(color[0], color[1], color[2]);

				// Create the particle system
				const particleSystem = new THREE.Points(geometry, materials[i]);

				/* Offset the particle system x, y, z to different random points to break
				uniformity in the direction of movement during animation */
				particleSystem.rotation.x = Math.random() * 6;
				particleSystem.rotation.y = Math.random() * 6;
				particleSystem.rotation.z = Math.random() * 6;

				particleSystems.push(particleSystem);
			}
			return particleSystems;
		}

		function RemoveBackground() {
			API.background_color = 0x000000;
			scene.background = null;
			render();
		}

		function ChangeBackgroundColor() {
			const h = Math.floor(getRandomFloat(0, 360));
			const newColor = "hsl(" + h + ", 100%, 15%)";

			API.background_color = new THREE.Color(newColor);
			scene.background = API.background_color;
			render();
		}

		//Color theme setup based on selection
		function ColorThemeSetter(theme) {
			switch (theme) {
				case 0: //Blue white
					ColorPalatte.patetteId = 0;
					ColorPalatte.background_color = 0x1d395b;
					ColorPalatte.primary_color = 0x046ec1;
					ColorPalatte.secondary_color = 0x24b9eb;
					ColorPalatte.text3dForegroundColor = 0x046ec1;
					ColorPalatte.text3dSideColor = 0xffffff;
					ColorPalatte.other_color = [0x1d395b, 0x046ec1, 0x24b9eb, 0xffffff];
                    particleSpriteLocation = "./textures/sprites/confettiblue/";
					break;
				case 1: //Gold black
					ColorPalatte.patetteId = 1;
					ColorPalatte.background_color = 0xb28a16;
					ColorPalatte.primary_color = 0x010103;
					ColorPalatte.secondary_color = 0xb0982b;
					ColorPalatte.text3dForegroundColor = 0x010103;
					ColorPalatte.text3dSideColor = 0xb28a16;
					ColorPalatte.other_color = [0xb28a16, 0x010103, 0xb0982b, 0xedd9a5];
                    particleSpriteLocation = "./textures/sprites/confettigold/";
					break;
			}
		}

		//Change theme of the application
		function ChangeTheme() {
			if (ColorPalatte.patetteId == 0) {
				ColorThemeSetter(1);
				colorThemeSelection = 1;
			}
			else if (ColorPalatte.patetteId == 1) {
				ColorThemeSetter(0);
				colorThemeSelection = 0;
			}
			scene.remove.apply(scene, scene.children);

			init();
		}

		//Audio player setup and play functionality
		function AudioPlayer() {
			// create an AudioListener and add it to the camera
			const listener = new THREE.AudioListener();
			camera.add(listener);

			// create a global audio source
			const sound = new THREE.Audio(listener);

			// load a sound and set it as the Audio object's buffer
			const audioLoader = new THREE.AudioLoader();
			audioLoader.load('/sounds/musicbox.wav', function (buffer) {
				sound.setBuffer(buffer);
				sound.setLoop(true);
				sound.setVolume(0.5);
				sound.autoplay = true;
				sound.play();
			});
		}
	</script>


</body>
</html>


<!--To do:
Check if ar support, else add scene background
Add wisher name
add bells - done
Add start - done
add snow - done
	reduce snow speed - done
	Move happy new year back - done
	sound to add  - done
	animate all part- done
	fireworks - 
	confetti - partial
	-->
